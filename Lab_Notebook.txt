1/13/2024
-----------------------------
1. Merged divide and conquer voronoi code into main code, called from optimizer.py
2. Note G.nodes is passing funny stuff, needed to convert it to list to fix bug
3. Is faster but still somewhat slow, potentially optimize via flood-fill algorithm
4. Last estimate for 2pi is 6.117158723854214 from using 30x30 grid and 24 nearest neighbors
5. Next programming to do is test cases for paper
perimeter of circle
perimeter of box
perimeter of sphere
pathological cases (too close to boundary of grid, etc)

estimate for perimeter of circle
6.117158723854214 using 30x30 grid with 24 nearest neighbors

need to make test for perimeter of sphere

3/12/2024 (Attempts to solve bad conditionin number problem)
-----------------------------
Prune lengths and edges to only include ratios of smallest to largest no more than 100

Throw away points that are very close to one another

make symmetric lookup table

5/3/2024
------------------------------
old table is likely 
Table seems to be screwed up, use the old 5k table instead 
fixed bug in reconstruct system, now returning correct paper weights for:

u = np.array([[(-1.0,0.0),(1.0,0.0),(0.0,-1.0),(0.0,1.0)\
              ,(-1.0,1.0),(1.0,1.0),(1.0,-1.0),(-1.0,-1.0)\
                  ,(-2.0,1.0),(-1.0,2.0),(1.0,2.0),(2.0,1.0)\
                      ,(2.0,-1.0),(1.0,-2.0),(-1.0,-2.0),(-2.0,-1.0)]])

made new testing file "testing_weights_5_3_2024.py"

!when calling get_weights outside of file!
be wary that list of points needs to be wrapped in extra layer of brackets []
lengths needs to then as a consequence be wrapped in brackets []


5/5/2024
------------------------------
Made a new 5,000,000 entry table

with:

points = np.array([(0.0,0.0),(-1.0,0.0),(1.0,0.0),(0.0,-1.0),(0.0,1.0)\
              ,(-1.0,1.0),(1.0,1.0),(1.0,-1.0),(-1.0,-1.0)\
                  ,(-2.0,1.0),(-1.0,2.0),(1.0,2.0),(2.0,1.0)\
                      ,(2.0,-1.0),(1.0,-2.0),(-1.0,-2.0),(-2.0,-1.0)])

and

flat_norm(points,np.ones(len(points)),lamb=1.0,neighbors=16)

we match kevin's constants print("KRV: ", [0.1221, 0.0476, 0.0454]) out to 4 decimal places

Making figure in fig_circ_irregular, lamb=0.0078125, lambda still doesn't match expectations 

looks like voronoi might be responsible for weird inconsistencies?

turning perturbations on, lambda = 2*0.0078125, bounding perturbations by 1e-7 keeps entire set, bounding instead by 1e-6 returns nothing kept

lambda scaling should be 2k/r, figure out what k is, should be pretty consistent, if r < 2*k/lambda then circ will disappear

one circ should disappear if lambda is between 4 < lambda < 8

investigate: weight_indices usage, see if indices work like we think they do

5/19/2024
------------------------
No voronoi areas on src/snk or weight:, 50^2 grid, r1 = 0.5, r2 = 0.25, neighbors = 24

lamb = 3.9 both disappear
lamb = 4.1 one disappears
lamb = 6.0 one disappears
lamb = 7.8 keep both (off behavior), but fixed by doing 100^2 grid
lambd = 8.1 keep both

seems like may be some small numerical issue, 100^2 grid with lamb = 8.1 yields 3 wrong points

0.0016 on weights only

n = 100
r1 = 0.5
r2 = 0.25
neighbors = 24

lamb = 3.9 keeps both
lamb = 0.1 keeps both

0.0016 areas on src\sink only

n = 100
r1 = 0.5
r2 = 0.25
neighbors = 24

lamb = 6.0 removes both

actual vornoi areas on src\sink only

n = 100
r1 = 0.5
r2 = 0.25
neighbors = 24

lamb = 3.9 both disappear
lamb = 4.1 bigger one starts to lose points on the boundary
lamb = 6.0 one disappears
lamb = 7.8 keeps bigger
lambd = 8.1 same excep=t 3 pickles
lamb = 6.0 

actual voronoi areas on src/sink/horiz




lamb = 6.0 what the fuck way off theres like a mnoon and shit
lamb = 3.9 disappeared both
lamb = 4.1 disappeared both
lamb = 5.0 messed up duuude

####################################
multiplying by nothing numerically agrees and glitches exactly the same as multiplying src and sink by voronoi
####################################

def flat_norm(points,E,lamb=1.0,perim_only=False,neighbors = 24):
    #main function
    n = len(points)
    if neighbors >= len(points):
        raise Exception("Need more points than neighbors")
    weightst0 = perf_counter()
    Tree,graph,weight_indices = calculate_tree_graph(points,neighbors)
    edges,lengths,vertices = calculate_edge_vectors(points,graph)
    areas = voronoi_areas(points,Tree)
    sorted_areas = np.sort(areas)
    vals,idx,occ = np.unique(sorted_areas,return_index=True,return_counts=True)
    vals = np.round(vals,4)
    weights = get_weights(edges, lengths)
    areas = np.ones(np.shape(areas))
    scaled_weights = np.multiply(weights,areas[:,np.newaxis]).flatten()
    temp = np.array(weights).flatten()
    print(np.max(np.abs(scaled_weights-temp)))
    weightst1 = perf_counter()
    perimt0 = perf_counter()
    row = weight_indices[:, 0]
    col = weight_indices[:, 1] 
    # this has the same effect as the adding entries for csr format
    #0 [10 1 11 20 2 12 21]
    graph_weights = np.append(temp,temp)
    rows_temp = np.append(row,col)
    cols_temp = np.append(col,row)
    sparse_temp = csr_array((graph_weights, (rows_temp, cols_temp)), shape=(n, n))
    graph_weights = np.append(scaled_weights,scaled_weights)
    rows = np.append(row,col)
    cols = np.append(col,row)
    sparse = csr_array((graph_weights, (rows, cols)), shape=(n, n))
    assert np.allclose(sparse_temp.toarray(),sparse.toarray())
    G = nx.from_scipy_sparse_array(temp)
    perim = get_perimeter(E,G)
    perimt1 = perf_counter()


fixed probable bug in weights for adjacency matrix 

not doubling weights in adjacency matrix for lamb = 4.2 

changing n = 100 to n = 200 with not symmetric, voronoi areas fixed to be 0.0016, both circles disappear
